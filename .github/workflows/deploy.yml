on:
  workflow_call:
    inputs:
      additional_certificate_arns:
        # Arrays are not supported by Github resuable workflow inputs. It might be best to
        #  move back to defining each environment workflow completely independently.
        default: "[]"
        description: "A set of additional ACM certificate ARNs to be assigned to the ALB listener."
        required: false
        type: string
      aws_region:
        description: The AWS region target for deployment
        required: true
        type: string
      aws_replication_region:
        description: The AWS replication region target for deployment
        required: true
        type: string
      aws_s3_terraform_state_object_key:
        description: The key of the Terraform .tfstate file in AWS S3
        required: true
        type: string
      dns_name:
        description: The DNS name to be configured as a Route53 hosted zone
        required: true
        type: string
      environment_name:
        description: The name of the environment configured in Github repository settings
        required: true
        type: string
      vpc_cidr_index:
        description: The integer of the second segment of the VPC IPv4 CIDR range, to avoid collisions
        required: true
        type: number
    secrets:
      aws_assume_role_arn:
        description: The AWS IAM role assumed by Github Actions
      aws_s3_terraform_state_bucket_name:
        description: The AWS S3 bucket name containing Terraform backends, configured in Github repository settings
        required: true

jobs:
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    steps:
      # Setup section
      - name: Clone the Git repository
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4.0.1
        with:
          role-to-assume: ${{ secrets.aws_assume_role_arn }}
          aws-region: ${{ inputs.aws_region }}

      # Terraform setup
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2

      - name: Terraform Format
        run: terraform fmt -check
        working-directory: ./terraform

      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.aws_s3_terraform_state_bucket_name }}" \
            -backend-config="key=${{ inputs.aws_s3_terraform_state_object_key }}" \
            -backend-config="region=${{ inputs.aws_region }}"
        working-directory: ./terraform

      - name: Terraform Apply - ECR only
        id: terraform-apply-ecr
        run: |
          terraform apply -auto-approve -target=aws_ecr_repository.hello_world \
            -var="aws_region=${{ inputs.aws_region }}" \
            -var="aws_replication_region=${{ inputs.aws_replication_region }}" \
            -var="dns_name=${{ inputs.dns_name }}" \
            -var="environment=${{ inputs.environment_name }}" \
            -var="image_tag=${{ github.sha }}" \
            -var="vpc_cidr_index=${{ inputs.vpc_cidr_index }}"
        working-directory: ./terraform

      # Docker section
      - name: Login to AWS ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag and push docker image to ECR
        id: build-image
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          REPOSITORY: "aws-swan-demo-${{ inputs.environment_name }}/hello-world"
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG .
          docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      # Terraform provision
      - name: Terraform Apply
        id: terraform-apply
        run: |
          terraform apply -auto-approve \
            -var="additional_certificate_arns=${{ inputs.additional_certificate_arns }}" \
            -var="aws_region=${{ inputs.aws_region }}" \
            -var="aws_replication_region=${{ inputs.aws_replication_region }}" \
            -var="dns_name=${{ inputs.dns_name }}" \
            -var="environment=${{ inputs.environment_name }}" \
            -var="image_tag=${{ github.sha }}" \
            -var="vpc_cidr_index=${{ inputs.vpc_cidr_index }}"
        working-directory: ./terraform

      # # Docker section
      # - name: Login to AWS ECR
      #   id: login-ecr
      #   uses: aws-actions/aws-ecr-login@v2

      # - name: Build, tag and push docker image to ECR
      #   id: build-image
      #   env:
      #     REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      #     REPOSITORY: "${{ steps.terraform-apply.outputs.namespace }}/hello-world"
      #     IMAGE_TAG: ${{ github.sha }}
      #   run: |
      #     docker build -t $REGISTRY/$REPOSITORY:$IMAGE_TAG .
      #     docker push $REGISTRY/$REPOSITORY:$IMAGE_TAG
      #     echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      # - name: Download task definition
      #   run: |
      #     aws ecs describe-task-definition --task-definition ${{ steps.terraform-apply.outputs.namespace }}-hello-world \
      #     --query taskDefinition > task-definition.json

      # - name: Fill in the new image ID in the Amazon ECS task definition
      #   id: task-definition
      #   uses: aws-actions/amazon-ecs-render-task-definition@v1
      #   with:
      #     task-definition: task-definition.json
      #     container-name: hello-world
      #     image: ${{ steps.build-image.outputs.image }}

      # - name: Deploy Amazon ECS task definition
      #   uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      #   with:
      #     task-definition: ${{ steps.task-definition.outputs.task-definition }}
      #     service: ${{ steps.terraform-apply.outputs.namespace }}-hello-world
      #     cluster: ${{ steps.terraform-apply.outputs.namespace }}
      #     wait-for-service-stability: true